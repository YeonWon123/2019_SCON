#include <iostream>
using namespace std;

// 접근
// Dynamic Programming으로 접근한다.
// 첫 번째 동전만 사용하여 각 k값마다 가능한 경우의 수를 찾는다.
// 첫 번째 - 두 번째 동전만 사용하였을 때, 각 k값마다 가능한 경우의 수를 찾는다.
// 이 때, 첫 번째 동전만 사용해서 구했던 경우의 수를 활용한다.
// 첫 번째 - n 번째 동전을 사용하였을 때까지 반복

// 점화식

// C(i) : i번째 코인의 가치
// D(i, k) : i번째 코인까지 사용하여 k를 만들 수 있는 경우의 수

// D(i, k) = D(i - 1, k)				  (만약 C(i) >  k일 때)
// D(i, k) = D(i, k - C(i)) + D(i - 1, k) (만약 C(i) <= k일 때)

/*

풀이
1) 첫 번째 동전만 사용한 경우

C(i) = [1, 2, 5]
D(i, k) =
		k   0   1   2   3   4   5   6   7   8   9   10
c(0)    [0] 1   0   0   0   0   0   0   0   0   0   0
c(1)    [1] 1   1   1   1   1   1   1   1   1   1   1

2) 두 번째 동전까지 사용한 경우

D(i, k) =
		k   0   1   2   3   4   5   6   7   8   9   10
c(0)    [0] 1   0   0   0   0   0   0   0   0   0   0
c(1)    [1] 1   1   1   1   1   1   1   1   1   1   1
c(2)    [2] 1   1   2   2   3   3   4   4   5   5   6

3) 세 번째 동전까지 사용한 경우

D(i, k) =
		k   0   1   2   3   4   5   6   7   8   9   10
c(0)    [0] 1   0   0   0   0   0   0   0   0   0   0
c(1)    [1] 1   1   1   1   1   1   1   1   1   1   1
c(2)    [2] 1   1   2   2   3   3   4   4   5   5   6
c(3)    [5] 1   1   2   2   3   4   5   6   7   8   10
*/
/*
n개의 종류 동전을 주고! k원을 만들 수 있는 경우의 수를 구하는 문제입니다.
종류가 1, 2, 5이고.. 10원을 만든다고 가정하면!

1원 = 1(1가지)

2원 = 1 + 1, 

		2

3원 = 1 + 1 + 1

   2 + 1

4원 = 1 + 1 + 1 + 1,

		1 + 1 + 2

		2 + 2

5원 = 1 + 1 + 1 + 1 + 1

		1 + 1 + 1 + 2

		 2 + 2 + 1

		 5
 ......
이렇게 갈 것입니다. 그렇다면 점화식을 어떻게 세워야할까요???

5원을 구한다고 생각하면
4원에서 + 1을 한 경우(1가지)
3원에서 + 2을 한 경우(2가지)
0원에서 + 5를 한 경우(1가지)
이렇게 총 4가지입니다.

해결 방법은..
1원에 대해서 먼저 dp를 채워줍니다.
그렇다면 k원까지 dp가 각각 1원으로 채워질 것입니다.

그리고 2원에 대해서 또 채워줍니다.
dp[2]의 값은 1에서 2가되겠지요(2가 추가되었으므로)
3원도 마찬가지로 1에서 2가되겠지요(1 + 2가 추가됨)
4원은 3이 될것입니다. 이유는(3 + 1과 2 + 2가 추가됨)

표로 그리면서 풀면 편할 것입니다..
이것을 점화식으로 세우면 아래의 코드와 같습니다.
coin[i]에 대해서 k원까지 돌고..
그 다음 코인에 대해서 k원까지 돌고...

for(int i = 0; i < n; i++)
{
	for(int j = 1; j <= k; j++)
	{
		if(j - coin[i] >= 0) dp[j] += dp[j - coin[i]];
	}
}
*/

int coins[101];
int dp[10001] = { 0, };

int main(void)
{
	int n, k;
	cin >> n >> k;

	for (int i = 1; i <= n; i++) {
		cin >> coins[i];
	}

	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++) {
			if (j >= coins[i]) {
				dp[j] += dp[j - coins[i]];
			}
		}
	}

	cout << dp[k];
	return 0;
}